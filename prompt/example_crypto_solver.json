[
    {
        "question": "Calculate 11^-1 mod 26",
        "answer": "Key Topic: Modular Arithmetic\nKey Knowledge: The modular inverse of a number a modulo m exists if and only if a and m are coprime i.e., gcda, m = 1. The modular inverse is the number z such that a * z ≡ 1 mod m.\nKnowledge Unit: Extended Euclidean Algorithm\nImportance: The Extended Euclidean Algorithm is essential for finding the modular inverse because it provides a method to express the greatest common divisor gcd of two numbers as a linear combination of those numbers. This is crucial in cryptography for key generation, encryption, and decryption processes.\n\nStep-by-step Solution:\nLet 11^-1 mod 26 = z for some z ∈ Z, that is, 11z ≡ 1 mod 26, that is, 11z -1 is multiple of 26. So, 11z -1 = 26y for some y ∈ Z, or equivalently, 11z - 26y = 1. It is the same as the Bezout's identity, 11x - 26y = 1 = gcd11,26.\nNow, we can use the Extended Euclidean Algorithm to get x.\n26 = 11 * 2 + 4\n11 = 4 * 2 + 3\n4 = 3 * 1 + 1\n1 = 4 - 3 * 1 = 4 - 11 - 4*2 * 1  = 4 - 11 + 4 * 2 = 11 + 4 * 3 = -11 + 26 - 11*2 * 3 = -11 + 26*3 - 11 * 6 = 26*3 -11*7\nSo we have  -11*7 + 26 * 3 = 1, compared with 11z - 26y = 1 to have z = -7, y = -3. That is, 11^-1 mod 26 = -7 always to make it positive, so 11^-1 mod 26 = -7 ≡ 19. Or 11^-1 = 19 mod 26"
    },
    {
        "question": "Suppose N = 33, p = 11, q = 3 N = pq, Given C=16, and select d = 7 for decryption, calculate C^d mod N",
        "answer": "Key Topic: RSA Decryption\nKey Knowledge: RSA decryption involves computing C^d mod N, where C is the ciphertext, d is the private decryption exponent, and N is the modulus N=pq for prime p and q. The Chinese Remainder Theorem CRT can simplify the computation by breaking it down into smaller, more manageable congruences.\nKnowledge Unit: Chinese Remainder Theorem CRT\nImportance: CRT is crucial in RSA decryption because it optimizes the computation, making it more efficient, especially for large numbers. By decomposing the problem into smaller congruences, CRT allows for faster calculations, which is essential for practical cryptographic applications.\n\nStep-by-step Solution:\nAn integer e for encryption key, such that ed = 1 mode 20. We can see easily that e = 3. Pre-compute: d_p = 7 mod 11-1 =10 = 7 and d_q = 7 mod 3-1 = 2 = 1\nSolve for a: a = 1 mod 11, a = 0 mod 3 to get a. We can use CRT or we can use modular concept directly. Here we try the direct way\nFrom {11, 3}, we start a =1 mod 11  <=> a = 11x +1 for some x\nPlug it in the second eq, 11x+1 = 0 mod 3. Take away multiple of 3, to get 2x + 1 = 0 mod 3\nSolve 2x +1 mod 3. It is trivial to see x =1 satisfies the condition. Therefore, a = 12 mod 33\nSolve for b: b = 0 mod 11, b = 1 mod 3. Same procedure to get b = 22 mod 33\n\nSuppose we are given C = 16, we want to compute C^d = 16^7 mod 33\nC is like ciphertext. In real application, C is very large, up to several hundreds of digits\nFind C_p = 16 mod 11 = 5 and C_q = 16 mod 3 = 1\nAnd x_p = 5^7 = 3 mod 11, x_q = 1^1 = 1 mod 3\nTherefore, 167 = 12 * 3 + 22 * 1 = 58 = 25 mod 33\nEasy to verify directly: 16^7 = 25 mod 33"
    },
    {
        "question": "Calculate the product of two-bit String [1, 0, 1, 1] * [0, 1, 1, 0] using GF2^4 with mx = x^4 + x^3 + 1",
        "answer": "Key Principle for Multiplying Polynomials in Finite Fields GF2^4:\nKey Topic: Finite Field Arithmetic\nKey Knowledge: In the finite field GF 2^4, multiplication of polynomials involves polynomial arithmetic modulo an irreducible polynomial. The irreducible polynomial mx defines the field, and any polynomial result must be reduced modulo this polynomial to ensure it remains within the field.\nKnowledge Unit: Irreducible Polynomial\nImportance: The irreducible polynomial is essential in defining the structure and properties of the finite field. It ensures that the field has the correct number of elements and allows for consistent and predictable arithmetic operations. This is crucial in cryptographic algorithms, error correction codes, and other applications where finite field arithmetic is used.\n\nStep-by-step Solution:\nTo calculate the product of two-bit strings [1, 0, 1, 1] * [0, 1, 1, 0] using GF2^4 with the irreducible polynomial mx = x^4 + x^3 + 1, we need to follow these steps:\n1. Represent the bit strings as polynomials:\n  [1, 0, 1, 1] corresponds to 1 * x^3 + 0 * x^2 + 1 * x + 1 = x^3 + x + 1.\n  [0, 1, 1, 0] corresponds to 0 * x^3 + 1 * x^2 + 1 * x + 0 = x^2 + x.\n2. Multiply these polynomials:\n  x^3 + x + 1 * x^2 + x = x^3 * x^2 + x^3 * x + x * x^2 + x * x + 1 * x^2 + 1 * x = x^5 + x^4 + x^3 + x^2 + x^2 + x\n  Since we are in GF2, we reduce 2x^2 to 0x^2 since 2 is congruent to 0 modulo 2: = x^5 + x^4 + x^3 + x\n3. Reduce the result modulo the irreducible polynomial mx = x^4 + x^3 + 1:\nWe perform polynomial division by x^4 + x^3 + 1 to reduce the polynomial x^5 + x^4 + x^3 + x. Divide x^5 by x^4 to get x. Multiply x by x^4 + x^3 + 1: x * x^4 + x^3 + 1 = x^5 + x^4 + x\nSubtract this from x^5 + x^4 + x^3 + x: x^5 + x^4 + x^3 + x - x^5 + x^4 + x = x^3\n\nThe remainder is x^3, which is our final result.\n\nTherefore, the product of [1, 0, 1, 1] and [0, 1, 1, 0] in GF2^4 with the irreducible polynomial mx = x^4 + x^3 + 1 is:\n\nBit String: [1, 0, 0, 0]\nPolynomial: x^3"
    },
    {
        "question": "Calculate log_21 mode 19",
        "answer": "Key Principle for Calculating Discrete Logarithms:\nKey Topic: Discrete Logarithms in Cyclic Groups\nKey Knowledge: In a cyclic group, the discrete logarithm log_ga is the exponent k such that g^k ≡ a mod n, where g is a generator primitive root of the group. To find log_21 mod 19, we identify a primitive root modulo 19 and solve for the exponent k such that 2^k ≡ 1 mod 19.\nKnowledge Unit: Primitive Root\nImportance: Identifying primitive roots is crucial in solving discrete logarithms, which are fundamental in various cryptographic protocols, including Diffie-Hellman key exchange and digital signatures. The security of these protocols often relies on the difficulty of solving discrete logarithm problems.\n\nStep-by-step Solution:\nTo calculate log_21 using cyclic groups, generators, and primitive roots, let's consider the cyclic group Z_19* the multiplicative group of integers modulo 19. The group Z_19* is generated by a primitive root g. We need to find such a primitive root and use it to calculate log_21.\n\n1. Identify a primitive root modulo 19:\n    A primitive root modulo n is an integer g such that its powers generate all integers from 1 to n-1. For modulo 19, we need to find g such that:\n    g^k mod 19 for k = 1, 2, ..., 18 generates all the elements from 1 to 18.\n2. Calculate powers of candidate primitive roots:\n    We will try some candidates typically starting from 2 upwards and calculate their powers to see if they generate all numbers from 1 to 18 modulo 19.\n3. Determine if the candidate is a primitive root:\n    If a candidate generates all numbers from 1 to 18, it is a primitive root.\n4. Use the primitive root to find log_21:\n    Once we have a primitive root g, we can express any number a as g^k mod 19. For log_21, we are looking for an integer k such that:\n    2^k ≡ 1 mod 19"
    },
    {
        "question": "DO Vigenere Encryption: m = theclassistough, k = apple",
        "answer": "Key Topic: Vigenere Cipher Encryption\nKey Knowledge: The Vigenere cipher is a method of encrypting alphabetic text by using a simple form of polyalphabetic substitution. A keyword is repeated to match the length of the plaintext, and each letter in the plaintext is shifted along some number of places according to the corresponding letter in the key.\nKnowledge Unit: Polyalphabetic Substitution\nImportance: The Vigenere cipher is a significant encryption technique in classical cryptography. While simple, it demonstrates the principle of using multiple cipher alphabets to reduce the incidence of letter frequency analysis.\n\nStep-by-step Solution:\nTo perform Vigenere encryption with the plaintext m = 'theclassistough' and key k = 'apple', follow these steps:\n\n1. Align the key with the plaintext:\n   Plaintext m:  t   h   e   c   l   a   s   s   i   s   t   o   u   g   h\n   Key k:        a   p   p   l   e   a   p   p   l   e   a   p   p   l   e\n\n2. Encrypt each letter by shifting according to the key:\n   - 't' with 'a' shift by 0: 't'\n   - 'h' with 'p' shift by 15: 'w'\n   - 'e' with 'p' shift by 15: 't'\n   - 'c' with 'l' shift by 11: 'n'\n   - 'l' with 'e' shift by 4: 'p'\n   - 'a' with 'a' shift by 0: 'a'\n   - 's' with 'p' shift by 15: 'h'\n   - 's' with 'p' shift by 15: 'h'\n   - 'i' with 'l' shift by 11: 't'\n   - 's' with 'e' shift by 4: 'w'\n   - 't' with 'a' shift by 0: 't'\n   - 'o' with 'p' shift by 15: 'd'\n   - 'u' with 'p' shift by 15: 'j'\n   - 'g' with 'l' shift by 11: 'r'\n   - 'h' with 'e' shift by 4: 'l'\n\n3. The final ciphertext is:\n   Ciphertext c: t   w   t   n   p   a   h   h   t   w   t   d   j   r   l"
    },
    {
        "question": "Apply a Salsa20 quarter-round to one of them: 1, 0, 0, 0, 0, 1, 0, 0 and 0, 0, 0, 1, where 1 = 00 00 00 01.",
        "answer": "Key Topic: Salsa20 Stream Cipher\nKey Knowledge: Salsa20 is a stream cipher that uses a series of quarter-round operations to generate a key stream. The quarter-round operation modifies four 32-bit words through a series of additions, XORs, and left rotations. The result is a new set of four words that will be further processed in the encryption routine.\nKnowledge Unit: Salsa20 Quarter-Round Operation\nImportance: Understanding the quarter-round operation is critical because it forms the backbone of the Salsa20 encryption process. The security and speed of Salsa20 are based on how effectively these operations mix the input bits.\n\nStep-by-step Solution:\nTo apply a Salsa20 quarter-round operation to the tuple 1, 0, 0, 0, follow these steps:\n\n1. Initialize the values:\n   Start with a = 1, b = 0, c = 0, d = 0.\n\n2. Compute the new value for b:\n   b = b ⊕ a + d <<< 7\n   = 0 ⊕ 1 <<< 7\n   = 00 00 00 00  00 00 00 00  00 00 00 00  10 00 00 00\n   = 00 00 00 80\n\n3. Compute the new value for c:\n   c = c ⊕ b + a <<< 9\n   = 0 ⊕ 81 <<< 9\n   = 00 00 00 00  00 00 00 00  00 00 00 10  00 00 00 00\n   = 00 01 02 00\n\n4. Compute the new value for d:\n   d = d ⊕ c + b <<< 13\n   = 0 ⊕ 00 01 02 00 + 00 00 00 80 <<< 13\n   = 00 01 02 80 <<< 13\n   = 20 50 00 00\n\n5. Compute the new value for a:\n   a = a ⊕ d + c <<< 18\n   = 1 ⊕ 20 51 02 00 <<< 18\n   = 1 ⊕ 08 00 81 44\n   = 08 00 81 45\n\n6. The final state after the quarter-round operation is:\n   1, 0, 0, 0 becomes 08 00 81 45, 00 00 00 80, 00 01 02 00, 20 50 00 00."
    },
    {
        "question": "Diffie-Hellman Key Exchange: Alice and Bob agree on g = 327 and p = 919.",
        "answer": "Key Topic: Diffie-Hellman Key Exchange\nKey Knowledge: The Diffie-Hellman key exchange is a method of securely exchanging cryptographic keys over a public channel. It is a specific method of securely exchanging cryptographic keys over a public channel and is one of the most common methods for setting up a shared secret over an unsecured communication channel.\nKnowledge Unit: Modular Exponentiation\nImportance: This protocol is foundational for many types of secure communications protocols and is used to establish a shared secret that can be used for secret communications while negotiating a secure channel.\n\nStep-by-step Solution:\n1. Alice and Bob agree on public values g = 327 and p = 919.\n2. Alice chooses a private key a = 400, computes her public key \\alpha = 327^{400} mod 919 = 231, and sends this to Bob.\n3. Bob chooses a private key \b = 729, computes his public key \\beta = 327^{729} mod 919 = 162, and sends this to Alice.\n4. Alice computes the shared secret k = 162^{400} mod 919 = 206.\n5. Bob computes the shared secret k = 231^{729} mod 919 = 206.\n6. Both confirm that their computed values of k are equal, establishing k = 206 as their shared secret key, used for encrypting subsequent communications."
    }

]
